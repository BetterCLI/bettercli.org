---
title: CLI Help pages
---

The Help page is often the first output the user sees from your command. It can act as _reference material_ listing and explaining available commands and options. But it could also be extended to document recommended usage, design considerations and other advanced topics. The most common way of surfacing it is to provide flags `-h` and `--help` - see [Showing CLI help]({{< relref "#showing-cli-help" >}}) below.

<!--more-->

## How to write CLI Help

It's important to remember, that Help is there for the users. A good Help should answer these questions right away:

1. **What does your program do?**

   - _One-liner_ description
   - A longer description of goals or capabilities if needed
   - Link to the project's website or relevant documentation site[^why-link]

2. Where to begin? Is there a recommended **sample command** to run for new users?
3. What are else can it do?
   - Show **Subcommands & Options**?
   - Describe additional use cases?

When trying to answer these questions, assume users don't know anything about your application. They randomly discovered it and maybe they hope it can help them with a task. You could build on that and also describe other parts of the program, for example:

- [Possible exit codes]({{< relref "exit-codes" >}}) and their meaning
- Links to project homepage, repository, documentation, other integrations…

### Reference or Documentation?

When documenting your application, you should decide whether you want to provide a _Reference_ or _Documentation_. Or both!

**Reference**:

- Describes available commands, options and their allowed usage.
- Should be autogenerated from the CLI application code. When the CLI reference documentation is autogenerated, it should be always up to date.
- Could be exported into multiple formats. And feeds into other integrations like [autocomplete]({{< relref "implement-shell-autocomplete" >}})
- Avoids complex topics like configuration, deployment scenarios etc.

**Documentation**:

- Describes available commands, options and their allowed usage, but in great detail.
- Could include
- Written by human

There is a

Depending on the size and complexity of your application, you could get by with a

There isn't a _proper_ standard for formatting CLI help pages. However, there are some common patterns and conventions to follow. A good starting point is to follow the structure and output of [man pages]({{< relref "#man-page" >}}). In general, it should look like this:

1. Name, Description and version
1. Usage and example usage
1. Available commands and options
1. Usage of other configuration options like environment variables or config files

**See Writing/generating Help**

You may print the Help text on running your app without any arguments and use it as an introduction for new users:

```console
$ mulitpush
Welcome to multipush!
```

However, if your application has a meaningful, primary action it can take it might make sense to run this action, without requiring users

Or print Help, or only a relevant parts of it, when CLI is invoked with missing or invalid options:

```console
$ mulitpush -a action.sh
\u001b[31m Missing "target" option! Use --target

Welcome to multipush!
```

## Long and short versions

A pattern you can see fairly often is to have two or more versions of the CLI documentation. For example:

- a short one, acting as a quick reference. It’s also usable for reference tools
- longer one, describing all the options and settings in details
- full on documentation, like a manpage, describing internal working

## Writing or generating a help text

### Generate help with frameworks

### Plain text files

### man page

Manpages (manual pages) are

Sphinx can generate them. How you can actually distribute them depends on the distribution channel you’ll employ.

You could provide a `man` subcommand: `$ multipush man`

### HTML

### PDF

### Docopt

## Showing CLI Help

The most common way is to provide flags `-h` and `--help`. Having a dedicated `help` command is also a good practice. Using this flag should always print help text to `stdout` and not to `stderr`, ignoring other flags that are set. You can provide a help text specific to subcommands. For example:

```text
{{% include "content/design/example-help.txt" %}}
```

You may invoke a Pager.

Note: see other common flags and options for CLI apps.

## Handling typos and wrong commands

Handling typos and invalid usage in CLI apps is an interesting challenge. Finding a good balance, depending on your tool’s audience and usage should be taken seriously. These behaviors are often configurable within your framework or arguments parsing libraries.

Being strict, and requiring all options to be typed correctly, with valid values and even in a specific order leads to a predictable CLI. With helpful error messages guiding users to a correct configuration. And consistent types and values for processing.

_But it could be limiting_ - maybe your validation is too strict and won’t allow for a perfectly valid value you didn’t think of? For example a validator for file path will reject a network path when it expects a local one. Or maybe your CLI is used in an environment where some other tool appends a meaningless and harmless option flag, that your CLI outright rejects. When you attempt to remove a flag, even in a manner where you don’t break functionality, suddenly users need to update all their usage and remove such flag.

On the other hand, being too lenient will lead to user’s frustration when they mistype or misuse an argument. You could also interpret is as _CLI lying to the user_, as it silently accepts wrong arguments. Typos in flag names are very common and without a warning message it makes your CLI looks like it’s ignoring user commands.

There is a case for both of these approaches. **You should think about design goals of your CLI** - maybe you want to ignore some things, like extraneous flag? Or a file path that looks invalid - if it’s indeed an invalid path, your application will eventually fail with a correct „Not a valid path“ error message. Or just warn on invalid values and typos instead of failing execution? Allowing users flexibility with their flags? And fail validation only on things you are sure would lead to a broken execution?

## CLI Help template

## Notes

### Reference tools like `tldr`, `wat`, `navi` or `Dash`

[https://github.com/agarrharr/awesome-cli-apps#command-line-learning](https://github.com/agarrharr/awesome-cli-apps#command-line-learning)

## See more

- defining flags
- Colors and formatting in CLI

[^why-link]: If your CLI is tied to a product, don't assume users are aware of it. Or already have account or API keys. Be explicit if they should familiarize and register themselves with a website/SaaS before.
